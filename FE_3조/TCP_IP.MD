# TCP/IP

## 역사

>### 1960년대
>>
>> - 미국 국방성에서 네트워크의 일부가 적의 공격으로 파괴되더라도 우회로를 통해 데이터를 전송하는, 통신이 정지하지 않는 네트워크가 필요했다.
>>
>> - 분산형 네트워크의 경우 한쪽이 공격을 받더라도 우회로가 있는 한 통신을 계속할 수 있음. 이런 분산형 네트워크인 패킷 통신의 필요성을 꾸준히 얘기해왔다.
>>
>>    - 여러 사용자가 하나의 회선을 동시에 공유할 수 있고, 이런 이용 효율이 회선 비용을 낮출 수 있는 장점을 갖고 있었기 때문이다.
>
>### 1969년
>>
>> - ARPA를 주축으로 개발한 ARPAnet에서 등장
>>    - 초기에는 TCP가 아닌 NCP를 사용
>>        - NCP : 다양한 통신 네트워크를 지원하기 보다는 지상에서의 무선 통신 환경을 중점으로 하는 프로토콜
>>        - NCP의 문제점
>>            1. 아파넷에 등록된 기계 외에는 네트워크에 참여할 수 없어 자율적인 확장을 생각했던 인터넷의 개념과는 맞지 않았음
>>            2. 에러처리가 불완전해서 중간에 패킷이 소실되면 멈추는 일도 잦음
>>
>> => NCP를 처음 고안한 밥 칸(=밥 멧칼프)은 새로운 버전의 프로토콜을 만들기로 결심
>>
>> 신 버전의 프로토콜은 많은 것이 필요했음.
>> 1. 각 네트워크는 독립적으로 유지하면서도, 인터넷에 접속될 때 특별한 변화나 조작이 없어야 함
>>
>> 2. 데이터 덩어리인 패킷이 목적지에 도달하지 못했을 때 원래 발신한 곳에서 재전송이 일어나야 함
>>
>> 3. 이런 네트워크 사이를 연결하는 보편적인 블랙박스 같은 것이 필요함 (추후 게이트웨이와 라우터라고 부름)
>>
>> 4. 데이터 패킷이 어디로 어떻게 가는 것이 좋은지에 대한 정보를 담고 있어야 함(일종의 네비게이션)
>>
>>
>### 1973년
>>
>>밥 칸은 이를 해결하기 위해 오리지널 NCP의 디자인도 잘 알고 있었고, 다양한 컴퓨터 운영 체제를 어떤 인터페이스로 연결할 지에 대한 지식을 갖추고 있던 빈트 서프와 만나 오늘날 인터넷 기기들의 소통 언어라고 할 수 있는 TCP/IP 프로토콜이 세상에 나올 수 있었다.

### 참고 자료
>
> - [거의 모든 인터넷의 역사 - TCP/IP와 이더넷의 탄생](https://www.venturesquare.net/514020)
> - [TCP/IP - 02 - 01 TCP/IP의 등장 배경과 역사](https://velog.io/@joung5846/TCPIP-02-01-TCPIP%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD%EA%B3%BC-%EC%97%AD%EC%82%AC)
> - [[PROTOCOL] TCP/IP 1: 역사와 기초 개념](https://musketpopeye.xyz/2020/12/04/tcpip1/)

## 계층
> ### **TCP/IP 4계층**
>> - 프로토콜 통신 과정에 초점을 맞춰 만든 계층
>> - 애플리케이션, 전송, 인터넷, 네트워크 접속 계층들로 나뉘어 있다.
>> > 데이터 전송 시 데이터는 애플리케이션에서 네트워크 접속 계층으로 이동한다.
>> > 데이터 수신 시 데이터는 네트워크 접속에서 애플리케이션 계층으로 이동한다.

> ### **4계층 애플리케이션 계층** 
>- 웹 서비스와 이메일과 같은 서비스를 사용자에게 제공하는 계층이다.
>> - 애플리케이션마다 별개로 존재하는 프로토콜이 독자적인 특징을 갖고 있는데, 따라서 애플리케이션의 종류만큼 다양한 프로토콜이 존재한다.
>> > **EX.** 웹서비스를 제공할 때는 HTTP, 파일을 전송할 때는 FTP, 메일을 보낼 때는 SMTP, 메일을 받을 때는 POP3 

> ### **3계층 전송 계층** 
> - 포트 번호로 송신지 애플리케이션에서 보낸 데이터가 수신지 컴퓨터의 어떤 애플리케이션으로 전송되어야 할지를 식별한다.
>> * **TCP와 UDP**
>> > **TCP:** 웹이나 이메일과 같이 데이터의 신뢰성과 정확성이 중요한 애플리케이션에서 사용한다.   
>> > **UDP:** 데이터가 일부 유실되더라도 원할 하게 볼 수 있도록 빠른 데이터 전송이 필요한 애플리케이션에서 사용한다.

> ### **2계층 인터넷 계층** 
>- 네트워크와 네트워크를 연결하여 직접 연결되지 않은 컴퓨터간에 데이터 통신을 구현한다.
>> - 대신, 이 작업에는 라우터라는 네트워크 장비가 필요하다.
>> 라우터들의 연쇄작용을 라우팅이라 하고, IP 주소와 라우팅에 대해 규정한 프로토콜이 IP 프로토콜이다.
>> > 1. 인터넷 계층은 데이터를 송신하는 호스트에서 수신하는 호스트까지 데이터 전송 경로를 책임진다.
>> > 2. 각 호스트는 유일한 번호로 부여된 IP 주소를 갖고 있고, 라우터는 이 IP 주소를 기반으로 전송할 경로를 찾아간다.

> ### **1계층 네트워크 접속 계층**
> - 인접한 네트워크 기기 간에 데이터를 전송하는 역할을 한다. (물리적으로 연결)
>> - 대표적인 프로토콜 : 이더넷 프로토콜
>> - 다른 계층과 달리 통신의 상대방이 반드시 같은 프로토콜을 사용할 필요는 없다.

>### 참고자료
> - [TCP/IP 와 TCP/IP 4계층이란?](https://wooono.tistory.com/507)
> - [OSI 7계층과 TCP/IP 4계층](https://carnival.tistory.com/58)
> - [TCP/IP 계층 기본 개념](https://reakwon.tistory.com/68)
> - [TCP / IP 4계층 모델](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-TCP-IP-%EC%A0%95%EB%A6%AC-%F0%9F%91%AB%F0%9F%8F%BD-TCP-IP-4%EA%B3%84%EC%B8%B5)
## 흐름
>
>### 송신(캡슐화)
>>
>> - 호스트의 각 계층을 지날 때 마다 해당 계층의 프로토콜을 처리하고 헤더를 추가하는 것
>>
>> -  송신 호스트의 각 계층에서 맡은 역할에 따라 프로토콜을 처리하고 상위 계층으로부터 받은 데이터에 헤더 라는 정보를 붙여 하위 계층으로 넘김
>>
>> - 상위 계층에서 받은 데이터를 해당 계층에서 헤더를 추가 한 다음 그 데이터를 하위 계층으로 전달합니다. 데이터가 최하위 계층에 도달할 때까지 반복하는 것
>>
>> - 헤더 : 수신 호스트의 해당 계층에서 데이터를 처리할 때 필요한 정보가 담겨 있고, 데이터는 -송신 호스트의 다음 하위 계층으로 전달하는 정보
>
 
>
>### 수신(역캡슐화)
>>
>> - 캡슐화와 정반대의 방향으로 수신지 호스트의 각 계층을 지날 때 마다 해당 계층의 프로토콜을 처리하고 데이터의 헤더가 삭제되는 것
>>
>> - 수신 호스트의 각 계층에서는 하위 계층으로부터 받은 데이터에 포함된 헤더 부분의 정보를 사용해서 해당 계층의 프로토콜을 처리한 후 헤더 부분을 제거한 데이터를 상위 계층으로 넘김
>>
>> - 하위 계층에서 받은 데이터에서 헤더 부분만 제거하고 상위 계층으로 보낸다. 이 과정을 최상위 계층에 닿을 때까지 반복하는 것
>
>
>
>#### 이런 과정을 거치는 이유 : 데이터를 보내기 위해선 데이터의 앞부분, 헤더에 전송하는데 필요한 정보를 붙여서 다음 계층으로 내보내기 때문

### 참고자료

> - [프론트엔드 기술 저장소](https://k-developer.gitbook.io/dev/http/http-network-1/1./1.3-tcp-ip)
> - [[Network]TCP/IP 각 계층과 통신의 흐름 파악하기](https://deftkang.tistory.com/22)



## 특징

### TCP

> 1. 신뢰성있는 데이터 통신을 가능하게 해주는 프로토콜
> 2. 커넥션 연결(3-way-handsake),양방향통신, 해제는 4-way-handsake
> 3. (이게 제일 중요한 특징)데이터의 순차 전송을 보장
>
> - SEQ(sequence,순서),ACK(acknowledge)로 수신 데이터 순서(offset)을 확인하고 누락/지연 패킷에 대한 재전송 알고리즘을 제공해 IP를 보완하기 때문에 수신된데이터를 읽어 들일때는 정확히 송신 순서에 맞게 데이터 누락없이 처리.
> - SEQ: 송신자와 수신자 서로 상대방에게 자신이 보내는 데이터 순서 정보
>   - 이를 통해 수신측에서는 상대방이 지금까지 나에게 보낸 데이터의 총량 확인.
>   - SEQ는 데이터 순서를 맞추는데 사용
> - ACK: 자신이 정상적으로 받은 데이터 정보
>   - 다음 수신이 와야하는 SEQ번호, 상대방이 받은 데이터의 총량 확인가능, 누락발생시 재전송해야하는 SEQ번호를 알 수 있음.
>   - 재전송은 상대방이 보내오는 ACK의 번호와 일치하는 SEQ번호의 데이터를 전송
>
> 4. 흐름제어: 송수신자 간의 데어터 속도 차이로 인해 발생하는 흐름문제를 제어
>
> - 송신자는 보내기만하면되지만 수신자측에서 데이터를 받아 처리하는 속도가 더딜 수 있는데 이때 처리하는 데이터의 양이 너무 많아지면 컴퓨터도 우리의 뇌와 마찬가지로 기억하는 양이 제한되어있는데 이를 초과하면 데이터가 손실됨.
> - 제어 방법
>   - 송신자는 자신이 한번에 보낼수있는 데이터양을 , 수신자는 자신이 처리할 수 있는 데이터 양을 끊임없이 확인하여 TCP Header 의 window size를 사용하여 한번에 받고/보낼수 있는 데이터 양을 정함.
>
> 5. 혼잡제어: 네트워크 관련하여 송신자 쪽에서 데이터를 보내도 네트워크속도가 느려 수신자측에서 데이터가 안와 통신이 제대로 안되는 문제를 제어
>
> - 제어 방법
>   - Slow Start: 송신자는 연결 초기에 데이터 송출량(데이터를 보내는량)을 낮게 잡고 보내면서 수신자의 수신을확인하여 데이터 송출량을 조절.

### IP

> 1. 통신 상대를 정하기 위해 네트워크상에 존재하는 모든 기기에 고유의 주소같은 것이 할당.
> 2. 비연결형 서비스를 제공
>
> - 패킷의 전달 순서, 패킷 분실 여부 등에서 연결형 서비스보다 신뢰성이 떨어지는 전송 방식
> - 패킷이 서로 다른 경로를 통해 목적지 호스트로 전달되기 때문에 패킷이 도착하는 순서가 일정하지 않을 수 있음 -> 상위계층인 전송계층은 수신한 패킷 순서를 재조정하는 기능이 필요.
>   - TCP의 데이터의 순차 전송을 보장이 이를 해결.
>
> 3. 패킷을 분할, 병합하는 기능을 수행
>
> - 네트워크마다 프레임 크기가 다르기 떄문에 분할이 필요하고, 이를 다시 병합.
> - 통신방법이 다른 네트워끼리 통신을 가능하게함( 케이블의 차이, 통신형식의 차이)
>
> 4. Best Effort 원칙에 따른 전송 기능을 제공
>
> - ‘노력은 하지만 결과는 보장하지 않는다’라는 뜻
> - 헤더가 깨지지 않았는지확인하거나 수신처의 주소가 존재하는지에 대한 판단 및 처리를 진행
> - 재전송 처리는 하지않음
> - 신뢰성을 보장하지 않는다는 의미
> - 예시(우편배달)  
>   4-1. 편지에 주소를 적어 보내면 우체부 아저씨가 수거해서 우체국에 모아서 보낼 주소지의 우체국으로 보낸 후 다시 우체부 아저씨가 주소지의 우편함에 편지를 가져다 놓게된다.  
>   4-2. 이때 이편지는 실제 사람에게 직접전달해 주는것이 아니고 또한 편지 받은 사람이 잘받았다고 연락하는것이 아니기에 편지를 보내는 사람은 잘 도착했는지 알 방법이 없음.  
>   4-3. 이것처럼 우체국은 최선의 노력을 다해 목적지 주소로 편지를 보내지만 실제 사람에게 전달되었는지에 대해 보장하지 않음.

### 참고자료

> - [데이터의 순차전송](https://sw-test.tistory.com/17)
> - [TCP전체적인 큰특징](https://www.youtube.com/watch?v=ikDVGYp5dhg)
> - [흐름제어](https://aws-hyoh.tistory.com/entry/TCPIP-쉽게-이해하기)
> - [흐름제어2](https://velog.io/@qjatn1009/TCP와-UDP)
> - [흐름제어3](https://roka88.dev/114)
> - [신뢰성 보장이유](https://github.com/lunchScreen/Interview_Questions/issues/97)
> - [IP의 주요특징](https://velog.io/@kpl5672/ip-프로토콜의-이해)
> - [Best Effort](https://whatchang.tistory.com/32)
> - [비연결 서비스](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jk130694&logNo=220731561157)

## 활용

- TCP/IP = 어떤 분야에서 사용하는가

> - 일반적인 기능에서 사용
>   - 메일
>   - 컴퓨터 간의 파일 전송
>   - 원격 로그인
> - 숨김
>   - tcp/ip는 전송 단위와 방법을 지정
>   - 네트워크 하드웨어의 세부 사항을 숨길 수 있다.
>   - 네트워크의 모든 머신이 네트워크 상의 다른 머신과 통신할 수 있도록
> - 인터넷 호스트 기능
>   - 네트워크에 연결된 여러 컴퓨터 사의 통신과 연결 허용
>   - 컴퓨터와 시스템을 네트워크에 접속
>   - 다른 인터넷 호스트와 통할 수 있는
>     <br></br>
>
> * 신뢰할 수 있는 TCP/IP
>   - 데이터를 주고 받는 두 사이에 주고 받음이 확실함
>   - 보낸 쪽에서는 내가 보낸 데이터를 상대방이 받았다는 응답을 보내야만 나머지를 보낼 수 있다.
>   - 이런 방법으로 데이터의 신뢰성을 높여준다.
>   - 데이터를 옮기는 과정에서 커다란 빅데이터를 여러 패킷으로 나누어 이동한다.
>     - 방대한 양의 데이터는 하나의 패킷으로만 주고 받기엔 무리가 있다.
>   - ip는 오로지 전송에만 집중하기에 여러 네트워크 통신망을 통해 패킷을 이동시키면 이동시키는 과정에서 패킷이 사라지거나 순서가 바뀔 수 있다.
>     - ip가 전송에 집중하느라 잃어버리거나 순서가 뒤바뀐 패킷을 되돌려 놓는다.
>     - 만약 패킷이 손실되었거나 잘못보내졌을때
>       - CHECKSUM 부분을 통해
>         송신자가 보낸 데이터가 제대로 보내졌는지 확인 할 수 있다.
>       - 잘못 보내졌을 경우 = reset(0) 값을 보낸다.
>       - 제대로 보내졌을 경우 = set(1)을 일렬번호에 +1 값을 넣어주면 된다
>     - 만약 패킷의 순서가 잘못되었을때
>       - 순서가 뒤바뀐 데이터도 문제가 되지 않는다.
>       - 할당되어 있는 번호가 있기에
>       - 수신자 측에서 이러한 순서대로 데이터를 정렬하여 붙여주기만 하면 된다.

### 참고자료

> - 참고자료
>   - [TCP 는 어떻게 신뢰성 있는 통신을 할까?](https://steemit.com/tcpipacknak/@znxkznxk1030/tcp)
>   - [TCP/IP(Transmission Control Protocol/Internet Protocol)](https://www.ibm.com/docs/ko/aix/7.1?topic=management-transmission-control-protocolinternet-protocol)
>   - [우아한 테그 10분 테크톡 tcp/ip](https://youtu.be/BEK354TRgZ8)
