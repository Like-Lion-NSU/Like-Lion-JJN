#  시간 복잡도
#### - 특정 알고리즘이 어떤 문제를 해결하는데 걸리는 시간
#### - 같은 결과를 갖는 프로그래밍 소스도 작성 방법에 따라 걸리는 시간이 달라지며, 같은 결과를 같는 소스라면 시간이 적게 걸리는 것이 좋은 소스

> ### 시간 복잡도 표기 종류
>   - 최악 , 최고, 평균의 값을 표기 
>   - 주로  Big-O 표기법 사용 (최악의 경우를 고려한다)
>
>- Big-O - 최악의 경우를 나타냄 
>  - O(n): 최악의 경우 n번까지 수행되면 프로그램을 끝낼 수 있음
> - Big-Omega - 최적의 경우를 나타냄 
>  - O(n): 최소 n번은 수행되어야 프로그램을 끝낼 수 있음
>- Theta  - 평균 (Big-O 와 Big-Omega값의 평균값)
>
> **평균인 세타 표기를 하면 가장 정확하고 좋겠지만 평가하기가 까다로움
그래서 최악의 경우인 빅오를 사용하는데 알고리즘이 최악일때의 경우를 판단하면
> 평균과 가까운 성능으로 예측하기 쉽기 때문**

### 시간복잡도 성능지표
![img.png](img.png)
여기서 n이란 입력되는 데이터의 수를 의미
N은 수행시간을 의미

```faster O(1) < O(log n) < O(nlog n) < O(n²) < O(2ⁿ) slower```

slower로 갈수록(즉, 오른쪽 방향으로 갈수록) 효율성이 떨어짐

![img_2.png](img_2.png)
```O(1) (Constant)```

- 입력 데이터의 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘


- 데이터가 얼마나 증가하든 성능에는 변함없이 일정함을 나타내고 있음


![img_1.png](img_1.png)
``` O(n) (Linear)```

- 입력 데이터의 크기에 비례해서 처리 시간이 걸리는 알고리즘

- n이 1번 늘어날 때마다 처리시간이 1 증가하여 선형적으로 증가함 (n 크기만큼 처리시간이 증가)

- 하나의 루프를 사용하여 단일 요소 집합을 반복 하는 경우 사용


```O(log₂ n) ```
- 입력 데이터의 크기가 커질수록 처리 시간이 로그(log: 지수 함수의 역함수)만큼 짧아지는 알고리즘

- 예를 들어 데이터가 10배가 되면, 처리 시간은 2배가 됨


``` O(n log₂ n) ```

- 데이터가 많아질수록 처리시간이 로그(log) 배만큼 더 늘어나는 알고리즘

- 예를 들어 데이터가 10배가 되면, 처리 시간은 약 20배가 됨


```O(n²)```

- 데이터가 많아질수록 처리시간이 급수적으로 늘어나는 알고리즘 

- 예를 들어 데이터가 10배가 되면, 처리 시간은 최대 100배가 됨
이중 for 문

```O(2ⁿ) ```

- 데이터량이 많아질수록 처리시간이 기하급수적으로 늘어나는 알고리즘

- 피보나치 수열